---
title: "CBB 2025 Rankings"
output:
  pdf_document: default
  html_document: default
date: "2025-11-05"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
Sys.setenv(TZ = "America/New_York")

START_DATE <- Sys.Date()
END_DATE   <- Sys.Date() + 7
library(hoopR)
library(dplyr)
library(lubridate)

# -------------------------------
# Step 1: Load schedule
# -------------------------------
cbb_all <- load_mbb_schedule(seasons = 2026) %>%
  mutate(date = as.Date(date)) %>%
  filter(
    home_id != away_id,
    !is.na(home_id),
    !is.na(away_id)
  )

# -------------------------------
# Step 2: Filter for Nov 1–4, 2025
# -------------------------------
season_start <- as.Date("2025-11-01")
today <- Sys.Date()

cbb_sel <- cbb_all %>%
  filter(date >= season_start & date <= today)

if (nrow(cbb_sel) == 0) {
  warning("No games in date range. Using all available games.")
  cbb_sel <- cbb_all
}

# Fallback if no games in that range
if (nrow(cbb_sel) == 0) {
  warning("No games available in the selected date range (Nov 1–7, 2025). Using all available games instead.")
  cbb_sel <- cbb_all
}

# -------------------------------
# Step 3: Prepare winner/loser dataset
# -------------------------------
cbb_clean <- cbb_sel %>%
  mutate(
    home_pts   = as.numeric(home_score),
    away_pts   = as.numeric(away_score),
    winner     = if_else(home_pts >= away_pts, home_short_display_name, away_short_display_name),
    winner_pts = if_else(home_pts >= away_pts, home_pts, away_pts),
    loser      = if_else(home_pts <  away_pts, home_short_display_name, away_short_display_name),
    loser_pts  = if_else(home_pts <  away_pts, home_pts, away_pts),
    winner     = trimws(winner),
    loser      = trimws(loser)
  ) %>%
  filter(!is.na(winner) & !is.na(loser) & !is.na(winner_pts) & !is.na(loser_pts)) %>%
  select(date, winner, winner_pts, loser, loser_pts)

# -------------------------------
# Step 4: Initialize Elo ratings
# -------------------------------
all_teams <- unique(c(cbb_clean$winner, cbb_clean$loser))
ratings <- data.frame(
  team = all_teams,
  rating = 1500,
  games_played = 0,
  stringsAsFactors = FALSE
)

# -------------------------------
# Step 5: Elo computation loop
# -------------------------------
k_factor <- 30
num_iter <- 10

for (iter in 1:num_iter) {
  for (i in 1:nrow(cbb_clean)) {
    winner_team <- cbb_clean$winner[i]
    loser_team  <- cbb_clean$loser[i]

    # Skip if teams not in ratings
    if (!(winner_team %in% ratings$team) | !(loser_team %in% ratings$team)) next

    rating_w <- ratings$rating[ratings$team == winner_team]
    rating_l <- ratings$rating[ratings$team == loser_team]

    expected_w <- 1 / (1 + 10^((rating_l - rating_w)/400))
    margin <- cbb_clean$winner_pts[i] - cbb_clean$loser_pts[i]
    adj_k <- k_factor * log(abs(margin) + 1)
    delta <- adj_k * (1 - expected_w)

    ratings$rating[ratings$team == winner_team] <- rating_w + delta
    ratings$rating[ratings$team == loser_team]  <- rating_l - delta

    ratings$games_played[ratings$team == winner_team] <- ratings$games_played[ratings$team == winner_team] + 1
    ratings$games_played[ratings$team == loser_team]  <- ratings$games_played[ratings$team == loser_team] + 1
  }

  # Optional: penalize teams with fewer than 4 games
  ratings <- ratings %>%
    mutate(rating = ifelse(games_played < 4, rating / 2, rating))
}

# -------------------------------
# Step 6: Create Elo ranking table
# -------------------------------
elo_ranking <- ratings %>%
  arrange(desc(rating)) %>%
  mutate(rank = row_number()) %>%
  select(rank, team, rating, games_played)

# -------------------------------
# Step 7: Print Elo rankings
# -------------------------------
print(elo_ranking)




```

```{r}
library(hoopR)
library(dplyr)
library(lubridate)
library(tibble)

# -------------------------------
# Step 1: Load schedule
# -------------------------------
cbb_all <- load_mbb_schedule(seasons = 2026) %>%
  mutate(date = as.Date(date)) %>%
  filter(
    home_short_display_name != away_short_display_name,
    !is.na(home_short_display_name),
    !is.na(away_short_display_name)
  )

# -------------------------------
# Step 2: Filter for Nov 1–4, 2025
# -------------------------------
season_start <- as.Date("2025-11-01")
today <- Sys.Date()

cbb_sel <- cbb_all %>%
  filter(date >= season_start & date <= today)

if (nrow(cbb_sel) == 0) {
  warning("No games in date range. Using all available games.")
  cbb_sel <- cbb_all
}

# Fallback if no games in that range
if (nrow(cbb_sel) == 0) {
  warning("No games available in the selected date range (Nov 1–7, 2025). Using all available games instead.")
  cbb_sel <- cbb_all
}

# -------------------------------
# Step 3: Prepare winner/loser dataset
# -------------------------------
cbb_clean <- cbb_sel %>%
  mutate(
    home_pts   = as.numeric(home_score),
    away_pts   = as.numeric(away_score),
    winner     = if_else(home_pts >= away_pts, home_short_display_name, away_short_display_name),
    winner_pts = if_else(home_pts >= away_pts, home_pts, away_pts),
    loser      = if_else(home_pts <  away_pts, home_short_display_name, away_short_display_name),
    loser_pts  = if_else(home_pts <  away_pts, home_pts, away_pts),
    winner     = trimws(winner),
    loser      = trimws(loser)
  ) %>%
  filter(!is.na(winner) & !is.na(loser) & !is.na(winner_pts) & !is.na(loser_pts)) %>%
  select(date, winner, winner_pts, loser, loser_pts)

# -------------------------------
# Step 4: Initialize Elo ratings
# -------------------------------
all_teams <- unique(c(cbb_clean$winner, cbb_clean$loser))
ratings <- data.frame(
  team = all_teams,
  rating = 1500,
  games_played = 0,
  stringsAsFactors = FALSE
)

# -------------------------------
# Step 5: Elo computation loop
# -------------------------------
k_factor <- 30
num_iter <- 10

for (iter in 1:num_iter) {
  for (i in 1:nrow(cbb_clean)) {
    winner_team <- cbb_clean$winner[i]
    loser_team  <- cbb_clean$loser[i]

    # Skip if teams not in ratings
    if (!(winner_team %in% ratings$team) | !(loser_team %in% ratings$team)) next

    rating_w <- ratings$rating[ratings$team == winner_team]
    rating_l <- ratings$rating[ratings$team == loser_team]

    expected_w <- 1 / (1 + 10^((rating_l - rating_w)/400))
    margin <- cbb_clean$winner_pts[i] - cbb_clean$loser_pts[i]
    adj_k <- k_factor * log(abs(margin) + 1)
    delta <- adj_k * (1 - expected_w)

    ratings$rating[ratings$team == winner_team] <- rating_w + delta
    ratings$rating[ratings$team == loser_team]  <- rating_l - delta

    ratings$games_played[ratings$team == winner_team] <- ratings$games_played[ratings$team == winner_team] + 1
    ratings$games_played[ratings$team == loser_team]  <- ratings$games_played[ratings$team == loser_team] + 1
  }

  # Optional: penalize teams with fewer than 4 games
  ratings <- ratings %>%
    mutate(rating = ifelse(games_played < 4, rating / 2, rating))
}

# -------------------------------
# Step 6: Compute final Elo rankings with best win info
# -------------------------------

# Create lookup for final ratings
team_ratings <- ratings %>%
  select(team, rating)

# Join each game’s winner with loser’s final Elo
game_with_elo <- cbb_clean %>%
  left_join(team_ratings, by = c("loser" = "team")) %>%
  rename(loser_final_elo = rating) %>%
  left_join(team_ratings, by = c("winner" = "team")) %>%
  rename(winner_final_elo = rating)

# For each team, find their best win (beating the highest-rated opponent)
best_wins <- game_with_elo %>%
  group_by(winner) %>%
  slice_max(order_by = loser_final_elo, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(
    team = winner,
    best_win = loser,
    best_win_elo = loser_final_elo,
    date,
    winner_pts,
    loser_pts
  )

# Merge best win info into Elo table
elo_ranking <- ratings %>%
  arrange(desc(rating)) %>%
  mutate(rank = row_number()) %>%
  left_join(best_wins, by = "team") %>%
  select(rank, team, rating, games_played, best_win, best_win_elo, date, winner_pts, loser_pts)

# -------------------------------
# Step 7: Display final rankings
# -------------------------------
elo_ranking %>%
  arrange(rank) %>%
  mutate(
    rating = round(rating, 1),
    best_win_elo = round(best_win_elo, 1)
  ) %>%
  as_tibble() %>%
  print(n = 30)
```


```{r}
ACC_teams <- c("Boston College","California","Clemson","Duke","Florida St","Georgia Tech",
               "Louisville","Miami","NC State","North Carolina","Notre Dame","Pitt",
               "SMU","Stanford","Syracuse","Virginia","Virginia Tech","Wake Forest")

Big_12_teams <- c("Arizona","Arizona St","BYU","Baylor","Cincinnati","Colorado","Houston",
                  "Iowa State","Kansas","Kansas St","Oklahoma St","TCU","Texas Tech",
                  "UCF","Utah","West Virginia")

Big_Ten_teams <- c("Illinois","Indiana","Iowa","Maryland","Michigan","Michigan St","Minnesota",
                   "Nebraska","Northwestern","Ohio State","Oregon","Penn State","Purdue","Rutgers",
                   "USC","UCLA","Washington","Wisconsin")

SEC_teams <- c("Alabama","Arkansas","Auburn","Florida","Georgia","Kentucky","LSU",
               "Mississippi St","Missouri","Oklahoma","Ole Miss","South Carolina","Tennessee",
               "Texas","Texas A&M","Vanderbilt")

Big_East_teams <- c("Butler","UConn","Creighton","DePaul","Georgetown","Marquette",
                    "Providence","St John's","Seton Hall","Villanova","Xavier")

conference_list <- list(
  ACC = ACC_teams,
  Big_East = Big_East_teams,
  Big_12 = Big_12_teams,
  SEC = SEC_teams,
  Big_Ten = Big_Ten_teams
)

# -------------------------------
# 2. Assign conference safely
# -------------------------------
elo_ranking <- elo_ranking %>%
  rowwise() %>%
  mutate(
    conference = {
      conf_name <- names(conference_list)[sapply(conference_list, function(teams) team %in% teams)]
      if(length(conf_name) == 0) NA_character_ else conf_name[1]
    }
  ) %>%
  ungroup()

# -------------------------------
# 3. Compute conference-specific Elo rankings
# -------------------------------
elo_by_conf <- lapply(names(conference_list), function(conf_name) {
  elo_ranking %>%
    filter(conference == conf_name) %>%
    arrange(desc(rating)) %>%
    mutate(rank_in_conf = row_number())
})

names(elo_by_conf) <- names(conference_list)

# -------------------------------
# 4. Print each conference ranking
# -------------------------------
for(conf_name in names(elo_by_conf)) {
  cat("\n---", conf_name, "Elo Rankings ---\n")
  print(elo_by_conf[[conf_name]])
}
```


```{r}

America_East_teams <- c(
  "Vermont", "NJIT", "UMBC", "Binghamton", "New Hampshire",
  "UAlbany", "UMass Lowell", "Bryant", "Maine"
)

American_teams <- c(
  "North Texas", "Tulane", "Temple", "Tulsa", "Wichita St",
  "Charlotte", "FAU", "East Carolina", "Memphis",
  "South Florida", "UTSA", "Rice", "UAB"
)

ASUN_teams <- c(
  "Austin Peay", "North Alabama", "E Kentucky", "C Arkansas",
  "FGCU", "Jacksonville", "Stetson", "West Georgia",
  "Queens", "North Florida", "Bellarmine", "Lipscomb"
)

Atlantic_10_teams <- c(
  "Davidson", "Duquesne", "George Mason", "Richmond", "Saint Louis",
  "G Washington", "Saint Joseph's", "St Bonaventure", "Dayton",
  "Fordham", "La Salle", "Rhode Island", "VCU", "Loyola Chicago"
)

# ===============================================================
# Combine into one conference list
# ===============================================================

conference_list <- list(
  America_East = America_East_teams,
  American = American_teams,
  ASUN = ASUN_teams,
  Atlantic_10 = Atlantic_10_teams
)

# ===============================================================
# Assign conference to each team in elo_ranking
# ===============================================================

elo_ranking <- elo_ranking %>%
  rowwise() %>%
  mutate(
    conference = {
      conf_name <- names(conference_list)[sapply(conference_list, function(teams) team %in% teams)]
      if (length(conf_name) == 0) NA_character_ else conf_name[1]
    }
  ) %>%
  ungroup()

# ===============================================================
# Compute conference-specific Elo rankings
# ===============================================================

elo_by_conf <- lapply(names(conference_list), function(conf_name) {
  elo_ranking %>%
    filter(conference == conf_name) %>%
    arrange(desc(rating)) %>%
    mutate(rank_in_conf = row_number())
})

names(elo_by_conf) <- names(conference_list)

# ===============================================================
# Print each conference ranking
# ===============================================================

for (conf_name in names(elo_by_conf)) {
  cat("\n---", conf_name, "Elo Rankings ---\n")
  print(elo_by_conf[[conf_name]])
}
```

```{r}

Big_Sky_teams <- c(
  "Idaho", "N Colorado", "Montana", "Idaho St", "Sacramento St",
  "Portland St", "Weber St", "Montana St", "N Arizona", "E Washington"
)

Big_South_teams <- c(
  "High Point", "Presbyterian", "Charleston So", "Radford", "SC Upstate",
  "Longwood", "UNC Asheville", "Winthrop", "Gardner-Webb"
)

Big_West_teams <- c(
  "UC Santa Barbara", "UC San Diego", "Cal Poly", "Bakersfield", "UC Davis",
  "UC Irvine", "UC Riverside", "CSU Northridge", "Hawai’i", "Fullerton", "Long Beach St"
)

Coastal_Athletic_teams <- c(
  "Stony Brook", "Elon", "Northeastern", "Towson", "William & Mary", "Monmouth",
  "North Carolina A&T", "UNC Wilmington", "Campbell", "Charleston", "Drexel", "Hampton", "Hofstra"
)

Conference_USA_teams <- c(
  "Liberty", "Jax State", "Kennesaw St", "Middle Tennessee", "New Mexico St",
  "Western KY", "Missouri St", "UTEP", "FIU", "Louisiana Tech",
  "Sam Houston", "Delaware"
)

# ===============================================================
# Combine into one conference list
# ===============================================================

conference_list <- list(
  Big_Sky = Big_Sky_teams,
  Big_South = Big_South_teams,
  Big_West = Big_West_teams,
  Coastal_Athletic = Coastal_Athletic_teams,
  Conference_USA = Conference_USA_teams
)

# ===============================================================
# Assign conference to each team in elo_ranking
# ===============================================================

elo_ranking <- elo_ranking %>%
  rowwise() %>%
  mutate(
    conference = {
      conf_name <- names(conference_list)[sapply(conference_list, function(teams) team %in% teams)]
      if (length(conf_name) == 0) NA_character_ else conf_name[1]
    }
  ) %>%
  ungroup()

# ===============================================================
# Compute conference-specific Elo rankings
# ===============================================================

elo_by_conf <- lapply(names(conference_list), function(conf_name) {
  elo_ranking %>%
    filter(conference == conf_name) %>%
    arrange(desc(rating)) %>%
    mutate(rank_in_conf = row_number())
})

names(elo_by_conf) <- names(conference_list)

# ===============================================================
# Print each conference ranking
# ===============================================================

for (conf_name in names(elo_by_conf)) {
  cat("\n---", conf_name, "Elo Rankings ---\n")
  print(elo_by_conf[[conf_name]])
}
```


```{r}
Horizon_League_teams <- c(
  "Milwaukee", "Robert Morris", "Youngstown St", "N Kentucky",
  "Cleveland St", "Detroit Mercy", "Green Bay", "Purdue FW",
  "Wright St", "IU Indianapolis", "Oakland"
)

Ivy_League_teams <- c(
  "Yale", "Harvard", "Columbia", "Princeton", "Penn",
  "Dartmouth", "Brown", "Cornell"
)

Metro_Atlantic_teams <- c(
  "Iona", "Siena", "Niagara", "Manhattan", "Marist",
  "Saint Peter’s", "Canisius", "Fairfield", "Mount St Marys",
  "Quinnipiac", "Sacred Heart", "Rider", "Merrimack"
)

Mid_American_teams <- c(
  "Bowling Green", "Buffalo", "Akron", "Miami OH", "Ball State",
  "Kent State", "C Michigan", "E Michigan", "UMass",
  "N Illinois", "Ohio", "Toledo", "W Michigan"
)

Mid_Eastern_teams <- c(
  "Norfolk St", "Howard", "Morgan St", "MD Eastern",
  "Coppin St", "Delaware St", "NC Central", "SC State"
)

# ===============================================================
# Combine into one conference list
# ===============================================================

conference_list <- list(
  Horizon_League = Horizon_League_teams,
  Ivy_League = Ivy_League_teams,
  Metro_Atlantic = Metro_Atlantic_teams,
  Mid_American = Mid_American_teams,
  Mid_Eastern = Mid_Eastern_teams
)

# ===============================================================
# Assign conference to each team in elo_ranking
# ===============================================================

elo_ranking <- elo_ranking %>%
  rowwise() %>%
  mutate(
    conference = {
      conf_name <- names(conference_list)[sapply(conference_list, function(teams) team %in% teams)]
      if (length(conf_name) == 0) NA_character_ else conf_name[1]
    }
  ) %>%
  ungroup()

# ===============================================================
# Compute conference-specific Elo rankings
# ===============================================================

elo_by_conf <- lapply(names(conference_list), function(conf_name) {
  elo_ranking %>%
    filter(conference == conf_name) %>%
    arrange(desc(rating)) %>%
    mutate(rank_in_conf = row_number())
})

names(elo_by_conf) <- names(conference_list)

# ===============================================================
# Print each conference ranking
# ===============================================================

for (conf_name in names(elo_by_conf)) {
  cat("\n---", conf_name, "Elo Rankings ---\n")
  print(elo_by_conf[[conf_name]])
}

```

```{r}
Missouri_Valley_teams <- c(
  "Belmont", "Northern Iowa", "S Illinois", "Drake", "Evansville",
  "Indiana St", "Murray St", "UIC", "Bradley", "Illinois St", "Valparaiso"
)

Mountain_West_teams <- c(
  "New Mexico", "Wyoming", "Colorado St", "Nevada", "San Diego St",
  "Utah State", "Boise St", "Fresno St", "Grand Canyon", "UNLV",
  "San José St", "Air Force"
)

Northeast_teams <- c(
  "C Connecticut", "Long Island", "Mercyhurst", "Le Moyne",
  "Stonehill", "New Haven", "Fairleigh Dickinson", "Chicago State",
  "Saint Francis", "Wagner"
)

Ohio_Valley_teams <- c(
  "UT Martin", "SIUE ", "Tennessee St", "Little Rock", "E Illinois",
  "Lindenwood", "Tennessee Tech", "Morehead St", "SE Missouri",
  "So Indiana", "W Illinois"
)

Patriot_League_teams <- c(
  "Bucknell", "American", "Boston University", "Army", "Colgate",
  "Lafayette", "Lehigh", "Loyola Maryland", "Navy", "Holy Cross"
)

Southern_Conference_teams <- c(
  "Mercer", "VMI", "ETSU", "Samford", "Chattanooga",
  "Furman", "The Citadel", "Wofford", "UNC Greensboro", "W Carolina"
)

Southland_Conference_teams <- c(
  "SF Austin", "Incarnate Word", "McNeese", "Hou Christian",
  "Lamar", "New Orleans", "E Texas A&M", "UT Rio Grande",
  "Texas A&M-CC", "Nicholls", "N'Western St", "SE Louisiana"
)

# ===============================================================
# Combine into one conference list
# ===============================================================

conference_list <- list(
  Missouri_Valley = Missouri_Valley_teams,
  Mountain_West = Mountain_West_teams,
  Northeast = Northeast_teams,
  Ohio_Valley = Ohio_Valley_teams,
  Patriot_League = Patriot_League_teams,
  Southern_Conference = Southern_Conference_teams,
  Southland_Conference = Southland_Conference_teams
)

# ===============================================================
# Assign conference to each team in elo_ranking
# ===============================================================

elo_ranking <- elo_ranking %>%
  rowwise() %>%
  mutate(
    conference = {
      conf_name <- names(conference_list)[sapply(conference_list, function(teams) team %in% teams)]
      if (length(conf_name) == 0) NA_character_ else conf_name[1]
    }
  ) %>%
  ungroup()

# ===============================================================
# Compute conference-specific Elo rankings
# ===============================================================

elo_by_conf <- lapply(names(conference_list), function(conf_name) {
  elo_ranking %>%
    filter(conference == conf_name) %>%
    arrange(desc(rating)) %>%
    mutate(rank_in_conf = row_number())
})

names(elo_by_conf) <- names(conference_list)

# ===============================================================
# Print each conference ranking
# ===============================================================

for (conf_name in names(elo_by_conf)) {
  cat("\n---", conf_name, "Elo Rankings ---\n")
  print(elo_by_conf[[conf_name]])
}
```

```{r}
Southwestern_Athletic_teams <- c(
  "Grambling", "Prairie View", "Alabama A&M", "Alabama St",
  "Bethune", "Miss Valley St", "Southern", "Jackson St",
  "Texas Southern", "Florida A&M", "Alcorn St", "AR-Pine Bluff"
)

Summit_League_teams <- c(
  "S Dakota St", "Oral Roberts", "Denver", "Kansas City",
  "N Dakota St", "South Dakota", "St Thomas (MN)",
  "North Dakota", "Omaha"
)

Sun_Belt_teams <- c(
  "South Alabama", "Troy", "Marshall", "Arkansas St", "Coastal",
  "GA Southern", "James Madison", "Old Dominion", "App State",
  "Louisiana", "Southern Miss", "Texas St", "UL Monroe", "Georgia St"
)

West_Coast_teams <- c(
  "LMU", "Gonzaga", "Portland", "Saint Mary's", "Santa Clara",
  "Oregon St", "Pepperdine", "Pacific", "San Diego", "San Francisco",
  "Seattle U", "Washington St"
)

Western_Athletic_teams <- c(
  "Abilene Chrstn", "CA Baptist", "UT Arlington", "Tarleton St",
  "Utah Tech", "Utah Valley", "Southern Utah"
)

# ===============================================================
# Combine into one conference list
# ===============================================================

conference_list <- list(
  Southwestern_Athletic = Southwestern_Athletic_teams,
  Summit_League = Summit_League_teams,
  Sun_Belt = Sun_Belt_teams,
  West_Coast = West_Coast_teams,
  Western_Athletic = Western_Athletic_teams
)

# ===============================================================
# Assign conference to each team in elo_ranking
# ===============================================================

elo_ranking <- elo_ranking %>%
  rowwise() %>%
  mutate(
    conference = {
      conf_name <- names(conference_list)[sapply(conference_list, function(teams) team %in% teams)]
      if (length(conf_name) == 0) NA_character_ else conf_name[1]
    }
  ) %>%
  ungroup()

# ===============================================================
# Compute conference-specific Elo rankings
# ===============================================================

elo_by_conf <- lapply(names(conference_list), function(conf_name) {
  elo_ranking %>%
    filter(conference == conf_name) %>%
    arrange(desc(rating)) %>%
    mutate(rank_in_conf = row_number())
})

names(elo_by_conf) <- names(conference_list)

# ===============================================================
# Print each conference ranking
# ===============================================================

for (conf_name in names(elo_by_conf)) {
  cat("\n---", conf_name, "Elo Rankings ---\n")
  print(elo_by_conf[[conf_name]])
}
```

```{r}

conference_list <- list(
  ACC = ACC_teams,
  Big_East = Big_East_teams,
  Big_12 = Big_12_teams,
  SEC = SEC_teams,
  Big_Ten = Big_Ten_teams,
  America_East = America_East_teams,
  American = American_teams,
  ASUN = ASUN_teams,
  Atlantic_10 = Atlantic_10_teams,
  Big_Sky = Big_Sky_teams,
  Big_South = Big_South_teams,
  Big_West = Big_West_teams,
  Coastal_Athletic = Coastal_Athletic_teams,
  Conference_USA = Conference_USA_teams,
  Horizon_League = Horizon_League_teams,
  Ivy_League = Ivy_League_teams,
  Metro_Atlantic = Metro_Atlantic_teams,
  Mid_American = Mid_American_teams,
  Mid_Eastern = Mid_Eastern_teams,
  Missouri_Valley = Missouri_Valley_teams,
  Mountain_West = Mountain_West_teams,
  Northeast = Northeast_teams,
  Ohio_Valley = Ohio_Valley_teams,
  Patriot_League = Patriot_League_teams,
  Southern_Conference = Southern_Conference_teams,
  Southland_Conference = Southland_Conference_teams,
  Southwestern_Athletic = Southwestern_Athletic_teams,
  Summit_League = Summit_League_teams,
  Sun_Belt = Sun_Belt_teams,
  West_Coast = West_Coast_teams,
  Western_Athletic = Western_Athletic_teams
)

# ============================================================
# 2. Assign conference to each team in elo_ranking
# ============================================================

elo_ranking <- elo_ranking %>%
  rowwise() %>%
  mutate(
    conference = {
      conf_name <- names(conference_list)[
        sapply(conference_list, function(teams) team %in% teams)
      ]
      if (length(conf_name) == 0) NA_character_ else conf_name[1]
    }
  ) %>%
  ungroup()

# ============================================================
# 3. Compute average Elo per conference + rank
# ============================================================

conference_elo_summary <- elo_ranking %>%
  filter(!is.na(conference)) %>% 
  group_by(conference) %>%
  summarise(
    avg_elo = mean(rating, na.rm = TRUE),
    sd_elo  = sd(rating, na.rm = TRUE),
    num_teams = n()
  ) %>%
  arrange(desc(avg_elo)) %>%
  mutate(rank = row_number())

# ============================================================
# 4. Print results
# ============================================================

cat("\n--- Average Elo by Conference ---\n")
print(conference_elo_summary)

# Optional: visualize for quick comparison
library(ggplot2)
ggplot(conference_elo_summary, aes(x = reorder(conference, avg_elo), y = avg_elo)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(
    title = "Average Elo Rating by Conference",
    x = "Conference",
    y = "Average Elo"
  ) +
  theme_minimal()
```


```{r}
# ============================================================
# NCAA Bracketology Simulation based on Elo Rankings
# ============================================================
library(hoopR)
library(dplyr)
library(lubridate)
library(tibble)
library(readr)
library(ggplot2)

# --- Step 0: Ensure the data folder exists
if (!dir.exists(file.path("CBB", "data"))) {
  dir.create(file.path("CBB", "data"), recursive = TRUE)
}

# --- Step 1: Identify automatic bids (top team in each conference)
auto_bids <- elo_ranking %>%
  filter(!is.na(conference)) %>%
  group_by(conference) %>%
  slice_max(order_by = rating, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  mutate(auto_bid = TRUE)

# --- Step 2: Select at-large teams (next best by Elo until total = 68)
remaining_slots <- 68 - nrow(auto_bids)

at_large <- elo_ranking %>%
  filter(!team %in% auto_bids$team) %>%
  arrange(desc(rating)) %>%
  slice_head(n = remaining_slots) %>%
  mutate(auto_bid = FALSE)

# --- Step 3: Combine full field
field_of_68 <- bind_rows(auto_bids, at_large) %>%
  arrange(desc(rating)) %>%
  mutate(overall_seed = row_number())

# --- Step 4: Assign bracket seed lines
#  Seeds 1–16 → 4 teams each, except 11 & 16 → 6 teams
seed_distribution <- c(
  rep(1:10, each = 4),
  rep(11, 6),
  rep(12:15, each = 4),
  rep(16, 6)
)
seed_distribution <- seed_distribution[1:68]

field_of_68 <- field_of_68 %>%
  mutate(seed = seed_distribution) %>%
  arrange(seed, desc(rating))



# --- Step 5: Count number of bids per conference
conference_bid_count <- field_of_68 %>%
  group_by(conference) %>%
  summarise(
    total_bids = n(),
    auto_bids = sum(auto_bid),
    at_large_bids = total_bids - auto_bids
  ) %>%
  arrange(desc(total_bids))

cat("\n--- Number of Teams per Conference ---\n")
print(conference_bid_count, n = nrow(conference_bid_count))

# --- Step 6: Output bracket summary
cat("\n--- NCAA Bracketology Field of 68 ---\n")
print(
  field_of_68 %>%
    select(seed, team, conference, rating, auto_bid) %>%
    arrange(seed, desc(rating)),
  n = 68
)

# --- Step 7: Elo rating distribution by seed
ggplot(field_of_68, aes(x = factor(seed), y = rating, fill = auto_bid)) +
  geom_boxplot() +
  labs(
    title = "Elo Rating Distribution by Seed (Field of 68)",
    x = "Seed Line",
    y = "Elo Rating",
    fill = "Auto-Bid?"
  ) +
  theme_minimal()

# --- Step 8: Total bids per conference visualization
ggplot(conference_bid_count, aes(x = reorder(conference, total_bids), y = total_bids)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  geom_text(aes(label = total_bids), hjust = -0.2) +
  labs(
    title = "Total NCAA Tournament Bids by Conference",
    x = "Conference",
    y = "Number of Teams"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10)) +
  ylim(0, max(conference_bid_count$total_bids) + 1)

write_csv(
  field_of_68 %>%
    select(seed, overall_seed, team, conference, rating, auto_bid),
  file.path("CBB", "data", "projected_bracket2026.csv")
)


```

```{r}
# Merge each game with final Elo ratings for winner and loser
game_elo <- merge(cbb_clean, ratings[, c("team", "rating")],
                  by.x = "loser", by.y = "team", all.x = TRUE)
names(game_elo)[names(game_elo) == "rating"] <- "loser_final_elo"

game_elo <- merge(game_elo, ratings[, c("team", "rating")],
                  by.x = "winner", by.y = "team", all.x = TRUE)
names(game_elo)[names(game_elo) == "rating"] <- "winner_final_elo"

# Compute total Elo beaten per team
elo_beaten <- aggregate(loser_final_elo ~ winner, data = game_elo, FUN = sum)
elo_beaten$games_won <- aggregate(loser_final_elo ~ winner, data = game_elo, FUN = length)$loser_final_elo

# Arrange descending by total Elo beaten and assign proper ranks
elo_beaten <- elo_beaten[order(-elo_beaten$loser_final_elo), ]
elo_beaten$rank <- seq_len(nrow(elo_beaten))  # reset row names to proper ranks

# Reset row names to remove the original row numbers
rownames(elo_beaten) <- NULL

# Select top 80 teams
top_80_elo_beaten <- head(elo_beaten, 80)

# Print results
print(top_80_elo_beaten)
```

```{r}
library(hoopR)
library(dplyr)
library(lubridate)
library(readr)

# -------------------------------
# Step 1: Load schedule
# -------------------------------
cbb_all <- load_mbb_schedule(seasons = 2026) %>%
  mutate(date = as.Date(date)) %>%
  filter(
    home_short_display_name != away_short_display_name,
    !is.na(home_short_display_name),
    !is.na(away_short_display_name)
  )

# -------------------------------
# Step 2: Filter date range
# -------------------------------
season_start <- as.Date("2025-11-01")
today <- Sys.Date()

cbb_sel <- cbb_all %>%
  filter(date >= season_start & date <= today)

if (nrow(cbb_sel) == 0) {
  warning("No games available yet. Using all available games.")
  cbb_sel <- cbb_all
}
if (nrow(cbb_sel) == 0) {
  cbb_sel <- cbb_all
}

# -------------------------------
# Step 3: Winner / loser dataset
# -------------------------------
cbb_clean <- cbb_sel %>%
  mutate(
    home_pts = as.numeric(home_score),
    away_pts = as.numeric(away_score),
    winner = if_else(home_pts > away_pts,
                     home_short_display_name,
                     away_short_display_name),
    loser  = if_else(home_pts < away_pts,
                     home_short_display_name,
                     away_short_display_name),
    winner_pts = if_else(home_pts > away_pts, home_pts, away_pts),
    loser_pts  = if_else(home_pts < away_pts, home_pts, away_pts),
    winner_conf_id = if_else(home_pts > away_pts,
                             home_conference_id,
                             away_conference_id),
    loser_conf_id  = if_else(home_pts < away_pts,
                             home_conference_id,
                             away_conference_id)
  ) %>%
  filter(!is.na(winner), !is.na(loser)) %>%
  select(date, winner, winner_pts, winner_conf_id,
         loser, loser_pts, loser_conf_id)

# -------------------------------
# Step 4: Conference lookup
# -------------------------------
conf_lookup <- cbb_all %>%
  filter(groups_is_conference == TRUE) %>%
  select(conference_id = groups_id,
         conference = groups_name) %>%
  distinct()

cbb_clean <- cbb_clean %>%
  left_join(conf_lookup,
            by = c("winner_conf_id" = "conference_id")) %>%
  rename(winner_conf = conference) %>%
  left_join(conf_lookup,
            by = c("loser_conf_id" = "conference_id")) %>%
  rename(loser_conf = conference) %>%
  mutate(
    winner_conf = ifelse(is.na(winner_conf), "Unknown", winner_conf),
    loser_conf  = ifelse(is.na(loser_conf), "Unknown", loser_conf)
  )

# -------------------------------
# Step 5: Initialize Elo
# -------------------------------
teams <- unique(c(cbb_clean$winner, cbb_clean$loser))

ratings <- data.frame(
  team = teams,
  rating = 1500,
  wins = 0,
  losses = 0,
  stringsAsFactors = FALSE
)

k_factor <- 30
num_iter <- 10

# -------------------------------
# Step 6: Elo computation
# -------------------------------
for (iter in seq_len(num_iter)) {
  for (i in seq_len(nrow(cbb_clean))) {
    
    w <- cbb_clean$winner[i]
    l <- cbb_clean$loser[i]
    
    rw <- ratings$rating[ratings$team == w]
    rl <- ratings$rating[ratings$team == l]
    
    expected_w <- 1 / (1 + 10^((rl - rw) / 400))
    margin <- cbb_clean$winner_pts[i] - cbb_clean$loser_pts[i]
    adj_k <- k_factor * log(abs(margin) + 1)
    delta <- adj_k * (1 - expected_w)
    
    ratings$rating[ratings$team == w] <- rw + delta
    ratings$rating[ratings$team == l] <- rl - delta
    
    ratings$wins[ratings$team == w] <- ratings$wins[ratings$team == w] + 1
    ratings$losses[ratings$team == l] <- ratings$losses[ratings$team == l] + 1
  }
  
  ratings <- ratings %>%
    mutate(rating = ifelse(wins + losses < 4, rating / 2, rating))
}

# -------------------------------
# Step 7: Best win
# -------------------------------
team_ratings <- ratings %>% select(team, rating)

best_wins <- cbb_clean %>%
  left_join(team_ratings, by = c("loser" = "team")) %>%
  rename(loser_elo = rating) %>%
  group_by(winner) %>%
  slice_max(loser_elo, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(team = winner,
         best_win = loser,
         best_win_elo = loser_elo)

# -------------------------------
# Step 8: Final Elo table
# -------------------------------
elo_ranking <- ratings %>%
  mutate(
    record = paste0(round(wins / 10, 1), "-", round(losses / 10, 1))
  ) %>%
  arrange(desc(rating)) %>%
  mutate(rank = row_number()) %>%
  left_join(best_wins, by = "team") %>%
  mutate(
    rating = round(rating, 1),
    best_win_elo = round(best_win_elo, 1)
  ) %>%
  select(rank, team, rating, record, best_win, best_win_elo)

write_csv(elo_ranking, file.path("CBB", "data", "CBB_Elo_2026.csv"))
```


```{r}
library(dplyr)

# --- Step 1: Assign conference for each team ---
elo_beaten <- elo_beaten %>%
  rowwise() %>%
  mutate(
    conference = {
      conf_name <- names(conference_list)[
        sapply(conference_list, function(teams) winner %in% teams)
      ]
      if (length(conf_name) == 0) NA_character_ else conf_name[1]
    }
  ) %>%
  ungroup()

# --- Step 2: Identify automatic bids (top team in each conference by resume/Elo beaten) ---
auto_bids <- elo_beaten %>%
  filter(!is.na(conference)) %>%
  group_by(conference) %>%
  slice_max(order_by = loser_final_elo, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  mutate(auto_bid = TRUE)

# --- Step 3: Fill at-large bids to reach 68 total ---
remaining_slots <- 68 - nrow(auto_bids)

at_large <- elo_beaten %>%
  filter(!winner %in% auto_bids$winner) %>%
  arrange(desc(loser_final_elo)) %>%
  slice_head(n = remaining_slots) %>%
  mutate(auto_bid = FALSE)

# --- Step 4: Combine full field ---
field_of_68 <- bind_rows(auto_bids, at_large) %>%
  arrange(desc(loser_final_elo)) %>%
  mutate(overall_rank = row_number())

# --- Step 5: Assign seed lines ---
seed_distribution <- c(
  rep(1:10, each = 4),
  rep(11, 6),
  rep(12:15, each = 4),
  rep(16, 6)
)
seed_distribution <- seed_distribution[1:68]

field_of_68 <- field_of_68 %>%
  mutate(seed = seed_distribution) %>%
  arrange(seed, desc(loser_final_elo))

# --- Step 6: Select output columns ---
bracketology_field <- field_of_68 %>%
  select(
    seed,
    team = winner,
    conference,
    games_won,
    auto_bid,
    overall_rank
  )

# --- Step 7: Track number of teams per conference ---
conference_bid_count <- bracketology_field %>%
  group_by(conference) %>%
  summarise(
    total_bids = n(),
    auto_bids = sum(auto_bid),
    at_large_bids = total_bids - auto_bids
  ) %>%
  arrange(desc(total_bids))

# --- Step 8: Print results ---
cat("\n--- Field of 68 Bracketology ---\n")
print(bracketology_field, n = 68)

cat("\n--- Conference Bid Count ---\n")
print(conference_bid_count)
```


```{r}
library(dplyr)
library(tidyr)

# ============================================================
# Define MAJOR conferences
# ============================================================

major_confs <- c("ACC", "Big_East", "Big_Ten", "Big_12", "SEC")

# Helper: get conference
get_conf <- function(team_name) {
  conf <- names(conference_list)[
    sapply(conference_list, function(teams) team_name %in% teams)
  ]
  if (length(conf) == 0) NA_character_ else conf[1]
}

# ============================================================
# Attach conference to each game
# ============================================================

games_with_conf <- cbb_clean %>%
  mutate(
    winner_conf = sapply(winner, get_conf),
    loser_conf  = sapply(loser,  get_conf)
  ) %>%
  filter(
    winner_conf %in% major_confs,
    loser_conf  %in% major_confs,
    winner_conf != loser_conf     # no same-conference games
  )

# ============================================================
# Build team-level W/L rows
# ============================================================

team_major_results <- bind_rows(
  # Wins
  games_with_conf %>%
    transmute(
      team = winner,
      team_conf = winner_conf,
      opp_conf  = loser_conf,
      result = "W"
    ),
  # Losses
  games_with_conf %>%
    transmute(
      team = loser,
      team_conf = loser_conf,
      opp_conf  = winner_conf,
      result = "L"
    )
)

# ============================================================
# Summarize record vs each OTHER major conference
# ============================================================

team_major_records <- team_major_results %>%
  group_by(team, team_conf, opp_conf) %>%
  summarise(
    wins   = sum(result == "W"),
    losses = sum(result == "L"),
    games  = n(),
    win_pct = wins / games,
    .groups = "drop"
  )

# ============================================================
# Attach Elo and rank teams WITHIN their conference
# ============================================================

team_major_records <- team_major_records %>%
  left_join(
    elo_ranking %>% select(team, rating),
    by = "team"
  ) %>%
  group_by(team_conf) %>%
  mutate(
    elo_rank_in_conf = dense_rank(desc(rating))
  ) %>%
  ungroup()

# ============================================================
# Output: ordered by Elo inside each MAJOR conference
# ============================================================

records_by_major_conf <- lapply(major_confs, function(conf) {
  team_major_records %>%
    filter(team_conf == conf) %>%
    arrange(elo_rank_in_conf, opp_conf)
})

names(records_by_major_conf) <- major_confs

# ============================================================
# Print results
# ============================================================

for (conf in major_confs) {
  cat("\n=====================================================\n")
  cat(conf, ": Records vs OTHER MAJOR Conferences\n")
  cat("=====================================================\n")
  
  print(
    records_by_major_conf[[conf]] %>%
      select(
        elo_rank_in_conf,
        team,
        rating,
        opp_conf,
        wins,
        losses,
        games,
        win_pct
      ),
    n = 100
  )
}
```


```{r}
library(dplyr)

# ============================================================
# Helper: get conference
# ============================================================

get_conf <- function(team_name) {
  conf <- names(conference_list)[
    sapply(conference_list, function(teams) team_name %in% teams)
  ]
  if (length(conf) == 0) NA_character_ else conf[1]
}

# ============================================================
# Attach conference info to games
# ============================================================

games_with_conf <- cbb_clean %>%
  mutate(
    winner_conf = sapply(winner, get_conf),
    loser_conf  = sapply(loser,  get_conf)
  ) %>%
  filter(!is.na(winner_conf) & !is.na(loser_conf))

# ============================================================
# Create team-level W/L rows
# ============================================================

team_results <- bind_rows(
  games_with_conf %>%
    transmute(
      conf = winner_conf,
      opponent_team = loser,
      opponent_conf = loser_conf,
      result = "W"
    ),
  games_with_conf %>%
    transmute(
      conf = loser_conf,
      opponent_team = winner,
      opponent_conf = winner_conf,
      result = "L"
    )
)

# ============================================================
# Aggregate to CONFERENCE vs TEAM
# ============================================================

conf_vs_team <- team_results %>%
  filter(conf != opponent_conf) %>%   # no same-conference games
  group_by(conf, opponent_conf, opponent_team) %>%
  summarise(
    wins   = sum(result == "W"),
    losses = sum(result == "L"),
    games  = n(),
    win_pct = wins / games,
    .groups = "drop"
  )

# ============================================================
# For each conference, find the TEAM they want to win
# in each OTHER conference
# ============================================================

conference_rooting_interests <- conf_vs_team %>%
  group_by(conf, opponent_conf) %>%
  slice_max(order_by = win_pct, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  arrange(conf, opponent_conf)

# ============================================================
# Pretty output
# ============================================================

for (conf_name in unique(conference_rooting_interests$conf)) {
  cat("\n=====================================================\n")
  cat(conf_name, "ROOTING INTERESTS\n")
  cat("=====================================================\n")
  
  print(
    conference_rooting_interests %>%
      filter(conf == conf_name) %>%
      select(
        opponent_conf,
        opponent_team,
        wins,
        losses,
        games,
        win_pct
      ),
    n = 50
  )
}
```

```{r}
library(dplyr)

# ============================================================
# Parameters
# ============================================================

major_confs <- c("ACC", "Big_East", "Big_Ten", "Big_12", "SEC")
top_n <- 3     # number of teams to root for per opponent conference

# ============================================================
# Helper: get conference
# ============================================================

get_conf <- function(team_name) {
  conf <- names(conference_list)[
    sapply(conference_list, function(teams) team_name %in% teams)
  ]
  if (length(conf) == 0) NA_character_ else conf[1]
}

# ============================================================
# Attach conference info to games
# ============================================================

games_with_conf <- cbb_clean %>%
  mutate(
    winner_conf = sapply(winner, get_conf),
    loser_conf  = sapply(loser,  get_conf)
  ) %>%
  filter(
    winner_conf %in% major_confs,
    loser_conf  %in% major_confs,
    winner_conf != loser_conf
  )

# ============================================================
# Build conference → opponent team results
# ============================================================

conf_team_results <- bind_rows(
  # Wins
  games_with_conf %>%
    transmute(
      conf = winner_conf,
      opponent_conf = loser_conf,
      opponent_team = loser,
      result = "W"
    ),
  # Losses
  games_with_conf %>%
    transmute(
      conf = loser_conf,
      opponent_conf = winner_conf,
      opponent_team = winner,
      result = "L"
    )
)

# ============================================================
# Aggregate and rank rooting interests
# ============================================================

major_conf_rooting <- conf_team_results %>%
  group_by(conf, opponent_conf, opponent_team) %>%
  summarise(
    wins   = sum(result == "W"),
    losses = sum(result == "L"),
    games  = n(),
    win_pct = wins / games,
    .groups = "drop"
  ) %>%
  arrange(conf, opponent_conf, desc(win_pct), desc(games))

# ============================================================
# Select TOP N teams per opponent conference
# ============================================================

major_conf_rooting_top <- major_conf_rooting %>%
  group_by(conf, opponent_conf) %>%
  slice_max(order_by = win_pct, n = top_n, with_ties = TRUE) %>%
  ungroup() %>%
  arrange(conf, opponent_conf, desc(win_pct))

# ============================================================
# Output
# ============================================================

for (conf_name in major_confs) {
  cat("\n=====================================================\n")
  cat(conf_name, "MAJOR-CONFERENCE ROOTING INTERESTS\n")
  cat("=====================================================\n")
  
  print(
    major_conf_rooting_top %>%
      filter(conf == conf_name) %>%
      select(
        opponent_conf,
        opponent_team,
        wins,
        losses,
        games,
        win_pct
      ),
    n = 100
  )
}
```


```{r}
library(dplyr)

# ============================================================
# 1. Define major conferences
# ============================================================
major_confs <- c("ACC", "Big_East", "Big_Ten", "Big_12", "SEC")

# ============================================================
# 2. Helper to get a team's conference
# ============================================================
get_conf <- function(team_name) {
  conf <- names(conference_list)[
    sapply(conference_list, function(teams) team_name %in% teams)
  ]
  if (length(conf) == 0) NA_character_ else conf[1]
}

# ============================================================
# 3. Attach conference and final Elo to games
# ============================================================
games_with_elo <- cbb_clean %>%
  mutate(
    winner_conf = sapply(winner, get_conf),
    loser_conf  = sapply(loser,  get_conf)
  ) %>%
  filter(
    winner_conf %in% major_confs,
    loser_conf %in% major_confs,
    winner_conf != loser_conf  # exclude same-conference games
  ) %>%
  # Add final Elo of winner and loser
  left_join(elo_ranking %>% select(team, rating), by = c("winner" = "team")) %>%
  rename(winner_elo = rating) %>%
  left_join(elo_ranking %>% select(team, rating), by = c("loser" = "team")) %>%
  rename(loser_elo = rating)

# ============================================================
# 4. Compute Elo change per game (winner gains, loser loses)
# ============================================================
games_with_elo <- games_with_elo %>%
  mutate(
    winner_elo_change = loser_elo,
    loser_elo_change  = -loser_elo
  )

# ============================================================
# 5. Aggregate by team vs opponent conference
# ============================================================
elo_vs_conf <- bind_rows(
  # Winner perspective
  games_with_elo %>%
    transmute(
      team = winner,
      team_conf = winner_conf,
      opp_conf  = loser_conf,
      elo_change = winner_elo_change
    ),
  # Loser perspective
  games_with_elo %>%
    transmute(
      team = loser,
      team_conf = loser_conf,
      opp_conf  = winner_conf,
      elo_change = loser_elo_change
    )
) %>%
  group_by(team_conf, opp_conf) %>%
  summarise(
    total_elo_change = sum(elo_change, na.rm = TRUE),
    avg_elo_change   = mean(elo_change, na.rm = TRUE),
    games            = n(),
    .groups = "drop"
  ) %>%
  arrange(team_conf, opp_conf)

# ============================================================
# 6. Print table
# ============================================================
for (conf_name in major_confs) {
  cat("\n=====================================================\n")
  cat(conf_name, ": Avg Elo change vs other major conferences\n")
  cat("=====================================================\n")
  
  print(
    elo_vs_conf %>%
      filter(team_conf == conf_name) %>%
      select(opp_conf, games, total_elo_change, avg_elo_change)
  )
}
```


```{r}
library(dplyr)

# ============================================================
# 1. Define major conferences and selected mid-majors
# ============================================================
major_confs <- c("ACC", "Big_East", "Big_Ten", "Big_12", "SEC")
selected_mid_majors <- c("Atlantic_10", "Mountain_West", "West_Coast", "American")
all_opponent_confs <- c(major_confs, selected_mid_majors)

# ============================================================
# 2. Helper to get a team's conference
# ============================================================
get_conf <- function(team_name) {
  conf <- names(conference_list)[
    sapply(conference_list, function(teams) team_name %in% teams)
  ]
  if (length(conf) == 0) NA_character_ else conf[1]
}

# ============================================================
# 3. Attach conference and final Elo to games
# ============================================================
games_with_elo <- cbb_clean %>%
  mutate(
    winner_conf = sapply(winner, get_conf),
    loser_conf  = sapply(loser,  get_conf)
  ) %>%
  filter(!is.na(winner_conf) & !is.na(loser_conf)) %>%
  # Only include major conference teams as row teams
  filter(winner_conf %in% major_confs | loser_conf %in% major_confs) %>%
  # Add final Elo of winner and loser
  left_join(elo_ranking %>% select(team, rating), by = c("winner" = "team")) %>%
  rename(winner_elo = rating) %>%
  left_join(elo_ranking %>% select(team, rating), by = c("loser" = "team")) %>%
  rename(loser_elo = rating)

# ============================================================
# 4. Compute Elo change per game (winner gains, loser loses)
# ============================================================
games_with_elo <- games_with_elo %>%
  mutate(
    winner_elo_change = loser_elo,
    loser_elo_change  = -loser_elo
  )

# ============================================================
# 5. Aggregate by major conference vs selected opponent conferences
# ============================================================
elo_vs_conf <- bind_rows(
  # Winner perspective
  games_with_elo %>%
    transmute(
      team = winner,
      team_conf = winner_conf,
      opp_conf  = loser_conf,
      elo_change = winner_elo_change
    ),
  # Loser perspective
  games_with_elo %>%
    transmute(
      team = loser,
      team_conf = loser_conf,
      opp_conf  = winner_conf,
      elo_change = loser_elo_change
    )
) %>%
  filter(team_conf %in% major_confs, opp_conf %in% all_opponent_confs) %>%
  group_by(team_conf, opp_conf) %>%
  summarise(
    total_elo_change = sum(elo_change, na.rm = TRUE),
    avg_elo_change   = mean(elo_change, na.rm = TRUE),
    games            = n(),
    .groups = "drop"
  ) %>%
  arrange(team_conf, opp_conf)

# ============================================================
# 6. Print table for each major conference vs selected conferences
# ============================================================
for (conf_name in major_confs) {
  cat("\n=====================================================\n")
  cat(conf_name, ": Avg Elo change vs major + selected mid-major conferences\n")
  cat("=====================================================\n")
  
  print(
    elo_vs_conf %>%
      filter(team_conf == conf_name) %>%
      select(opp_conf, games, total_elo_change, avg_elo_change)
  )
}
```


```{r}
library(hoopR)
library(dplyr)
library(lubridate)
library(tibble)
library(readr)

# -------------------------------
# Step 1: Load schedule
# -------------------------------
cbb_all <- load_mbb_schedule(seasons = 2026) %>%
  mutate(date = as.Date(date)) %>%
  filter(
    home_short_display_name != away_short_display_name,
    !is.na(home_short_display_name),
    !is.na(away_short_display_name)
  )

# -------------------------------
# Step 2: Filter for Nov 1–Jan 21
# -------------------------------
season_start <- as.Date("2025-11-01")
today <- Sys.Date()

cbb_sel <- cbb_all %>%
  filter(date >= season_start & date <= today)

if (nrow(cbb_sel) == 0) {
  warning("No games available yet. Using all available games.")
  cbb_sel <- cbb_all
}

if (nrow(cbb_sel) == 0) {
  warning("No games in date range. Using all available games.")
  cbb_sel <- cbb_all
}

# -------------------------------
# Step 3: Prepare winner/loser dataset
# -------------------------------
cbb_clean <- cbb_sel %>%
  mutate(
    home_pts   = as.numeric(home_score),
    away_pts   = as.numeric(away_score),
    winner     = if_else(home_pts > away_pts, home_short_display_name, away_short_display_name),
    winner_pts = if_else(home_pts > away_pts, home_pts, away_pts),
    loser      = if_else(home_pts < away_pts, home_short_display_name, away_short_display_name),
    loser_pts  = if_else(home_pts < away_pts, home_pts, away_pts)
  ) %>%
  filter(!is.na(winner) & !is.na(loser)) %>%
  select(date, winner, winner_pts, loser, loser_pts)

# -------------------------------
# Step 4: Initialize Elo & tracking
# -------------------------------
all_teams <- unique(c(cbb_clean$winner, cbb_clean$loser))
ratings <- data.frame(
  team = all_teams,
  rating = 1500,
  wins = 0,
  losses = 0,
  stringsAsFactors = FALSE
)

k_factor <- 30
num_iter <- 10

# -------------------------------
# Step 5: Elo computation loop
# -------------------------------
for (iter in 1:num_iter) {
  for (i in 1:nrow(cbb_clean)) {
    winner_team <- cbb_clean$winner[i]
    loser_team  <- cbb_clean$loser[i]
    
    rating_w <- ratings$rating[ratings$team == winner_team]
    rating_l <- ratings$rating[ratings$team == loser_team]
    
    expected_w <- 1 / (1 + 10^((rating_l - rating_w)/400))
    margin <- cbb_clean$winner_pts[i] - cbb_clean$loser_pts[i]
    adj_k <- k_factor * log(abs(margin) + 1)
    delta <- adj_k * (1 - expected_w)
    
    ratings$rating[ratings$team == winner_team] <- rating_w + delta
    ratings$rating[ratings$team == loser_team]  <- rating_l - delta
    
    # Update W-L record
    ratings$wins[ratings$team == winner_team] <- ratings$wins[ratings$team == winner_team] + 1
    ratings$losses[ratings$team == loser_team] <- ratings$losses[ratings$team == loser_team] + 1
  }
  
  # Optional: penalize teams with fewer than 4 games
  ratings <- ratings %>%
    mutate(rating = ifelse((wins + losses) < 4, rating / 2, rating))
}

# -------------------------------
# Step 6: Compute best win for each team
# -------------------------------
team_ratings <- ratings %>% select(team, rating)

game_with_elo <- cbb_clean %>%
  left_join(team_ratings, by = c("loser" = "team")) %>%
  rename(loser_final_elo = rating) %>%
  left_join(team_ratings, by = c("winner" = "team")) %>%
  rename(winner_final_elo = rating)

best_wins <- game_with_elo %>%
  group_by(winner) %>%
  slice_max(order_by = loser_final_elo, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(
    team = winner,
    best_win = loser,
    best_win_elo = loser_final_elo
  )

# -------------------------------
# Step 7: Create final Elo ranking with scaled record
# -------------------------------
elo_ranking <- ratings %>%
  mutate(
    wins_scaled = round(wins / 10, 1),
    losses_scaled = round(losses / 10, 1),
    record = paste0(wins_scaled, "-", losses_scaled)
  ) %>%
  arrange(desc(rating)) %>%
  mutate(rank = row_number()) %>%
  left_join(best_wins, by = "team") %>%
  select(rank, team, rating, record, best_win, best_win_elo)

# Round Elo ratings
elo_ranking <- elo_ranking %>%
  mutate(rating = round(rating, 1),
         best_win_elo = round(best_win_elo, 1))

# -------------------------------
# Step 8: Write CSV
# -------------------------------
write_csv(
  elo_ranking,
  file.path("CBB", "data", "CBB_Elo_2026.csv")
)
print(elo_ranking)
```






```{r}
library(hoopR)
library(dplyr)
library(readr)

# ===============================
# USER SETTINGS
# ===============================
START_DATE <- Sys.Date()  # start projecting from today
HCA <- 65
ELO_BASELINE <- 1500
SPREAD_SCALE <- 35

# ===============================
# LOAD CURRENT Elo AND RECORD
# ===============================
elo <- read_csv(
  file.path("CBB", "data", "CBB_Elo_2026.csv"),
  show_col_types = FALSE
) %>%
  mutate(
    wins = as.numeric(sub("-.*", "", record)),
    losses = as.numeric(sub(".*-", "", record)),
    proj_wins = wins,
    proj_losses = losses
  ) %>%
  select(team, rating, proj_wins, proj_losses)

# ===============================
# LOAD FULL SCHEDULE
# ===============================
schedule <- load_mbb_schedule(seasons = 2026) %>%
  mutate(
    date = as.Date(date),
    home_score = as.numeric(home_score),
    away_score = as.numeric(away_score)
  )

# ===============================
# FILTER FUTURE UNPLAYED GAMES
# ===============================
future_games <- schedule %>%
  filter(
    date >= START_DATE,
    (is.na(home_score) | home_score == 0),
    (is.na(away_score) | away_score == 0),
    !is.na(home_short_display_name),
    !is.na(away_short_display_name)
  ) %>%
  arrange(date)

if(nrow(future_games)==0) stop("No unplayed games found in the schedule.")

# ===============================
# PROJECT REMAINING GAMES
# ===============================
for(i in 1:nrow(future_games)){
  
  home <- future_games$home_short_display_name[i]
  away <- future_games$away_short_display_name[i]
  neutral <- future_games$neutral_site[i]
  
  home_elo <- elo$rating[elo$team == home]
  away_elo <- elo$rating[elo$team == away]
  
  if(length(home_elo)==0) home_elo <- ELO_BASELINE
  if(length(away_elo)==0) away_elo <- ELO_BASELINE
  
  home_adj <- ifelse(neutral, home_elo, home_elo + HCA)
  
  # Expected win probability
  home_win_pct <- 1 / (1 + 10^((away_elo - home_adj)/400))
  
  # Update projected wins/losses
  elo$proj_wins[elo$team == home] <- elo$proj_wins[elo$team == home] + home_win_pct
  elo$proj_losses[elo$team == home] <- elo$proj_losses[elo$team == home] + (1 - home_win_pct)
  
  elo$proj_wins[elo$team == away] <- elo$proj_wins[elo$team == away] + (1 - home_win_pct)
  elo$proj_losses[elo$team == away] <- elo$proj_losses[elo$team == away] + home_win_pct
  
  # Update Elo for next game
  k_factor <- 30
  delta <- k_factor * (home_win_pct - 0.5)
  elo$rating[elo$team == home] <- home_elo + delta
  elo$rating[elo$team == away] <- away_elo - delta
}

# ===============================
# FORMAT FINAL PROJECTED RECORD
# ===============================
projected_records <- elo %>%
  mutate(
    proj_record = paste0(round(proj_wins,1), "-", round(proj_losses,1))
  ) %>%
  arrange(desc(rating)) %>%
  select(team, proj_record)

# ===============================
# WRITE CSV
# ===============================
write_csv(
  projected_records,
  file.path("CBB", "data", "CBB_Projected_Final_Records_2026.csv")
)
print(projected_records)
```

```{r}
library(hoopR)
library(dplyr)
library(readr)
library(tidyr)

# ===============================
# USER SETTINGS
# ===============================
START_DATE <- Sys.Date()  # adjust as needed
HCA <- 65                 # home court advantage in Elo
ELO_BASELINE <- 1500
SPREAD_SCALE <- 35        # optional

# ===============================
# LOAD CURRENT Elo AND RECORD
# ===============================
elo <- read_csv(
  file.path("CBB", "data", "CBB_Elo_2026.csv"),
  show_col_types = FALSE
) %>%
  mutate(
    # Parse record like "16-3" and scale back if it was multiplied
    wins = as.numeric(sub("-.*", "", record))/10,
    losses = as.numeric(sub(".*-", "", record))/10,
    proj_wins = wins,
    proj_losses = losses
  ) %>%
  select(team, rating, proj_wins, proj_losses)

# ===============================
# LOAD FULL SCHEDULE
# ===============================
schedule <- load_mbb_schedule(seasons = 2026) %>%
  mutate(
    date = as.Date(date),
    home_score = as.numeric(home_score),
    away_score = as.numeric(away_score)
  )

played_games <- schedule %>%
  filter(!is.na(home_score) & !is.na(away_score))

future_games <- schedule %>%
  filter(date >= START_DATE,
         is.na(home_score) | home_score == 0,
         is.na(away_score) | away_score == 0)

# ===============================
# PROJECT REMAINING GAMES
# ===============================
for(i in 1:nrow(future_games)){
  
  home <- future_games$home_short_display_name[i]
  away <- future_games$away_short_display_name[i]
  neutral <- future_games$neutral_site[i]
  
  home_elo <- elo$rating[elo$team == home]
  away_elo <- elo$rating[elo$team == away]
  
  if(length(home_elo)==0) home_elo <- ELO_BASELINE
  if(length(away_elo)==0) away_elo <- ELO_BASELINE
  
  home_adj <- ifelse(neutral, home_elo, home_elo + HCA)
  
  home_win_pct <- 1 / (1 + 10^((away_elo - home_adj)/400))
  
  # Update projected wins/losses
  elo$proj_wins[elo$team == home] <- elo$proj_wins[elo$team == home] + home_win_pct
  elo$proj_losses[elo$team == home] <- elo$proj_losses[elo$team == home] + (1 - home_win_pct)
  
  elo$proj_wins[elo$team == away] <- elo$proj_wins[elo$team == away] + (1 - home_win_pct)
  elo$proj_losses[elo$team == away] <- elo$proj_losses[elo$team == away] + home_win_pct
  
  # Update Elo for next game
  k_factor <- 30
  delta <- k_factor * (home_win_pct - 0.5)
  elo$rating[elo$team == home] <- home_elo + delta
  elo$rating[elo$team == away] <- away_elo - delta
}

# ===============================
# CALCULATE SCHEDULE STRENGTH (SOS)
# ===============================
avg_elo <- function(team, games, elo_df){
  opponents <- c(
    games$away_short_display_name[games$home_short_display_name == team],
    games$home_short_display_name[games$away_short_display_name == team]
  )
  if(length(opponents)==0) return(NA)
  mean(elo_df$rating[elo_df$team %in% opponents], na.rm=TRUE)
}

teams <- elo$team
sos_df <- data.frame(team = teams, stringsAsFactors = FALSE)

sos_df$current_sos <- sapply(teams, function(t) avg_elo(t, played_games, elo))
sos_df$remaining_sos <- sapply(teams, function(t) avg_elo(t, future_games, elo))
sos_df$total_sos <- (sos_df$current_sos + sos_df$remaining_sos)/2

# ===============================
# COUNT ACTUAL GAMES PLAYED
# ===============================
games_played <- played_games %>%
  select(home_team = home_short_display_name, away_team = away_short_display_name) %>%
  pivot_longer(cols = everything(), values_to = "team") %>%
  group_by(team) %>%
  summarise(games_played = n(), .groups = "drop")

# Ensure all teams included
games_played <- elo %>%
  select(team) %>%
  left_join(games_played, by = "team") %>%
  mutate(games_played = ifelse(is.na(games_played), 0, games_played))

# ===============================
# APPLY 1000 ELO PENALTY FOR <8 GAMES
# ===============================
sos_df <- sos_df %>%
  left_join(games_played, by = "team") %>%
  mutate(
    current_sos = ifelse(games_played < 8, current_sos - 1000, current_sos),
    remaining_sos = ifelse(games_played < 8, remaining_sos - 1000, remaining_sos),
    total_sos = ifelse(games_played < 8, total_sos - 1000, total_sos)
  )

# ===============================
# RANK SOS (1 = hardest)
# ===============================
sos_df <- sos_df %>%
  mutate(
    current_rank = rank(-current_sos, ties.method = "min"),
    remaining_rank = rank(-remaining_sos, ties.method = "min"),
    total_rank = rank(-total_sos, ties.method = "min")
  )

# ===============================
# FINAL OUTPUT: PROJECTED RECORD + SOS
# ===============================
final_df <- elo %>%
  mutate(
    proj_record = paste0(round(proj_wins,2), "-", round(proj_losses,2))
  ) %>%
  left_join(sos_df, by = "team") %>%
  mutate(
    current_sos = round(current_sos,2),
    remaining_sos = round(remaining_sos,2),
    total_sos = round(total_sos,2),
    current_rank = round(current_rank,2),
    remaining_rank = round(remaining_rank,2),
    total_rank = round(total_rank,2)
  ) %>%
  arrange(desc(rating)) %>%
  select(team, proj_record, current_sos, current_rank,
         remaining_sos, remaining_rank, total_sos, total_rank)

# ===============================
# WRITE CSV
# ===============================
#write_csv(final_df, file.path("CBB", "data", "CBB_Projected_Records_SOS_2026.csv"))
print(final_df)
```

```{r}
library(hoopR)
library(dplyr)
library(readr)
library(tidyr)

# ===============================
# USER SETTINGS
# ===============================
START_DATE <- Sys.Date()  # Change to your desired projection start
HCA <- 65                 # Home court advantage in Elo
ELO_BASELINE <- 1500
SPREAD_SCALE <- 35        # Not used here, but can be for spreads

# ===============================
# LOAD CURRENT Elo AND RECORD
# ===============================
elo <- read_csv(
  file.path("CBB", "data", "CBB_Elo_2026.csv"),
  show_col_types = FALSE
) %>%
  mutate(
    # Parse record like "16-3" into wins/losses
    wins = as.numeric(sub("-.*", "", record)),
    losses = as.numeric(sub(".*-", "", record)),
    proj_wins = wins,
    proj_losses = losses
  ) %>%
  select(team, rating, proj_wins, proj_losses)

# ===============================
# LOAD FULL SCHEDULE
# ===============================
schedule <- load_mbb_schedule(seasons = 2026) %>%
  mutate(
    date = as.Date(date),
    home_score = as.numeric(home_score),
    away_score = as.numeric(away_score)
  )

played_games <- schedule %>%
  filter(!is.na(home_score) & !is.na(away_score))

future_games <- schedule %>%
  filter(date >= START_DATE,
         is.na(home_score) | home_score == 0,
         is.na(away_score) | away_score == 0)

# ===============================
# PROJECT REMAINING GAMES
# ===============================
for(i in 1:nrow(future_games)){
  
  home <- future_games$home_short_display_name[i]
  away <- future_games$away_short_display_name[i]
  neutral <- future_games$neutral_site[i]
  
  home_elo <- elo$rating[elo$team == home]
  away_elo <- elo$rating[elo$team == away]
  
  if(length(home_elo)==0) home_elo <- ELO_BASELINE
  if(length(away_elo)==0) away_elo <- ELO_BASELINE
  
  home_adj <- ifelse(neutral, home_elo, home_elo + HCA)
  
  home_win_pct <- 1 / (1 + 10^((away_elo - home_adj)/400))
  
  # Update projected wins/losses
  elo$proj_wins[elo$team == home] <- elo$proj_wins[elo$team == home] + home_win_pct
  elo$proj_losses[elo$team == home] <- elo$proj_losses[elo$team == home] + (1 - home_win_pct)
  
  elo$proj_wins[elo$team == away] <- elo$proj_wins[elo$team == away] + (1 - home_win_pct)
  elo$proj_losses[elo$team == away] <- elo$proj_losses[elo$team == away] + home_win_pct
  
  # Update Elo for next game
  k_factor <- 30
  delta <- k_factor * (home_win_pct - 0.5)
  elo$rating[elo$team == home] <- home_elo + delta
  elo$rating[elo$team == away] <- away_elo - delta
}

# ===============================
# CALCULATE SCHEDULE STRENGTH (SOS)
# ===============================
# Function to compute average opponent Elo
avg_elo <- function(team, games, elo_df){
  opponents <- c(
    games$away_short_display_name[games$home_short_display_name == team],
    games$home_short_display_name[games$away_short_display_name == team]
  )
  if(length(opponents)==0) return(NA)
  mean(elo_df$rating[elo_df$team %in% opponents], na.rm=TRUE)
}

teams <- elo$team
sos_df <- data.frame(team = teams, stringsAsFactors = FALSE)

# Current schedule SOS
sos_df$current_sos <- sapply(teams, function(t) avg_elo(t, played_games, elo))
# Remaining schedule SOS
sos_df$remaining_sos <- sapply(teams, function(t) avg_elo(t, future_games, elo))
# Total schedule SOS
sos_df$total_sos <- (sos_df$current_sos + sos_df$remaining_sos)/2

# Count games played
games_played <- played_games %>%
  select(home_team = home_short_display_name, away_team = away_short_display_name) %>%
  pivot_longer(cols = everything(), values_to = "team") %>%
  group_by(team) %>%
  summarise(games_played = n(), .groups = "drop")

# Ensure all teams included
games_played <- elo %>%
  select(team) %>%
  left_join(games_played, by = "team") %>%
  mutate(games_played = ifelse(is.na(games_played), 0, games_played))

# Penalize teams with less than 8 games
sos_df <- sos_df %>%
  left_join(games_played, by = "team") %>%
  mutate(
    current_sos = ifelse(games_played < 8, current_sos - 1000, current_sos),
    remaining_sos = ifelse(games_played < 8, remaining_sos - 1000, remaining_sos),
    total_sos = ifelse(games_played < 8, total_sos - 1000, total_sos)
  )

# Rank schedules (1 = hardest)
sos_df <- sos_df %>%
  mutate(
    current_rank = rank(-current_sos, ties.method = "min"),
    remaining_rank = rank(-remaining_sos, ties.method = "min"),
    total_rank = rank(-total_sos, ties.method = "min")
  )

# ===============================
# FINAL OUTPUT: Projected Record + SOS
# ===============================
final_df <- elo %>%
  mutate(
    proj_record = paste0(round(proj_wins,2), "-", round(proj_losses,2))
  ) %>%
  left_join(sos_df, by = "team") %>%
  mutate(
    current_sos = round(current_sos,2),
    remaining_sos = round(remaining_sos,2),
    total_sos = round(total_sos,2),
    current_rank = round(current_rank,2),
    remaining_rank = round(remaining_rank,2),
    total_rank = round(total_rank,2)
  ) %>%
  arrange(desc(rating)) %>%
  select(team, proj_record, current_sos, current_rank,
         remaining_sos, remaining_rank, total_sos, total_rank)

# ===============================
# WRITE CSV
# ===============================
write_csv(
  final_df,
  file.path("CBB", "data", "CBB_Projected_Records_SOS_2026.csv")
)
print(final_df)
```

```{r}
library(hoopR)
library(dplyr)
library(lubridate)
library(tibble)
library(readr)

# -------------------------------
# Step 1: Load schedule
# -------------------------------
cbb_all <- load_mbb_schedule(seasons = 2026) %>%
  mutate(date = as.Date(date)) %>%
  filter(
    home_short_display_name != away_short_display_name,
    !is.na(home_short_display_name),
    !is.na(away_short_display_name)
  )

# -------------------------------
# Step 2: Filter for Nov 1–Jan 21
# -------------------------------
season_start <- as.Date("2025-11-01")
today <- Sys.Date()

cbb_sel <- cbb_all %>%
  filter(date >= season_start & date <= today)

if (nrow(cbb_sel) == 0) {
  warning("No games available yet. Using all available games.")
  cbb_sel <- cbb_all
}

if (nrow(cbb_sel) == 0) {
  warning("No games in date range. Using all available games.")
  cbb_sel <- cbb_all
}

# -------------------------------
# Step 3: Prepare winner/loser dataset with conference IDs
# -------------------------------
cbb_clean <- cbb_sel %>%
  mutate(
    home_pts   = as.numeric(home_score),
    away_pts   = as.numeric(away_score),
    winner     = if_else(home_pts > away_pts, home_short_display_name, away_short_display_name),
    loser      = if_else(home_pts < away_pts, home_short_display_name, away_short_display_name),
    winner_pts = if_else(home_pts > away_pts, home_pts, away_pts),
    loser_pts  = if_else(home_pts < away_pts, home_pts, away_pts),
    winner_conf_id = if_else(home_pts > away_pts, home_conference_id, away_conference_id),
    loser_conf_id  = if_else(home_pts < away_pts, home_conference_id, away_conference_id)
  ) %>%
  filter(!is.na(winner) & !is.na(loser)) %>%
  select(date, winner, winner_pts, winner_conf_id, loser, loser_pts, loser_conf_id)

# -------------------------------
# Step 4: Build conference lookup table
# -------------------------------
conf_lookup <- cbb_all %>%
  filter(groups_is_conference == TRUE) %>%
  select(conference_id = groups_id, conference_name = groups_name) %>%
  distinct()

# Map IDs to names
cbb_clean <- cbb_clean %>%
  left_join(conf_lookup %>% rename(winner_conf_id = conference_id,
                                   winner_conf = conference_name),
            by = "winner_conf_id") %>%
  left_join(conf_lookup %>% rename(loser_conf_id = conference_id,
                                   loser_conf = conference_name),
            by = "loser_conf_id") %>%
  mutate(
    winner_conf = ifelse(is.na(winner_conf), "Unknown", winner_conf),
    loser_conf  = ifelse(is.na(loser_conf), "Unknown", loser_conf)
  )

# -------------------------------
# Step 5: Initialize Elo & tracking
# -------------------------------
all_teams <- unique(c(cbb_clean$winner, cbb_clean$loser))
ratings <- data.frame(
  team = all_teams,
  rating = 1500,
  wins = 0,
  losses = 0,
  stringsAsFactors = FALSE
)

k_factor <- 30
num_iter <- 10

# -------------------------------
# Step 6: Elo computation loop (unchanged)
# -------------------------------
for (iter in 1:num_iter) {
  for (i in 1:nrow(cbb_clean)) {
    winner_team <- cbb_clean$winner[i]
    loser_team  <- cbb_clean$loser[i]
    
    rating_w <- ratings$rating[ratings$team == winner_team]
    rating_l <- ratings$rating[ratings$team == loser_team]
    
    expected_w <- 1 / (1 + 10^((rating_l - rating_w)/400))
    margin <- cbb_clean$winner_pts[i] - cbb_clean$loser_pts[i]
    adj_k <- k_factor * log(abs(margin) + 1)
    delta <- adj_k * (1 - expected_w)
    
    ratings$rating[ratings$team == winner_team] <- rating_w + delta
    ratings$rating[ratings$team == loser_team]  <- rating_l - delta
    
    # Update W-L record
    ratings$wins[ratings$team == winner_team] <- ratings$wins[ratings$team == winner_team] + 1
    ratings$losses[ratings$team == loser_team] <- ratings$losses[ratings$team == loser_team] + 1
  }
  
  # Optional: penalize teams with fewer than 4 games
  ratings <- ratings %>%
    mutate(rating = ifelse((wins + losses) < 4, rating / 2, rating))
}

# -------------------------------
# Step 7: Compute best win for each team
# -------------------------------
team_ratings <- ratings %>% select(team, rating)

game_with_elo <- cbb_clean %>%
  left_join(team_ratings, by = c("loser" = "team")) %>%
  rename(loser_final_elo = rating) %>%
  left_join(team_ratings, by = c("winner" = "team")) %>%
  rename(winner_final_elo = rating)

best_wins <- game_with_elo %>%
  group_by(winner) %>%
  slice_max(order_by = loser_final_elo, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(
    team = winner,
    best_win = loser,
    best_win_elo = loser_final_elo
  )

# -------------------------------
# Step 8: Create final Elo ranking with scaled record
# -------------------------------
elo_ranking <- ratings %>%
  mutate(
    wins_scaled = round(wins / 10, 1),
    losses_scaled = round(losses / 10, 1),
    record = paste0(wins_scaled, "-", losses_scaled)
  ) %>%
  arrange(desc(rating)) %>%
  mutate(rank = row_number()) %>%
  left_join(best_wins, by = "team") %>%
  select(rank, team, rating, record, best_win, best_win_elo) %>%
  mutate(rating = round(rating, 1),
         best_win_elo = round(best_win_elo, 1))

# -------------------------------
# Step 9: Write team Elo CSV
# -------------------------------
write_csv(elo_ranking, file.path("CBB", "data", "CBB_Elo_2026.csv"))
print(elo_ranking)

# -------------------------------
# Step 10: Compute conference averages & non-conference record
# -------------------------------
completed_games <- cbb_clean %>% filter(!is.na(winner_pts) & !is.na(loser_pts))

# Non-conference record
conf_summary <- completed_games %>%
  filter(winner_conf != loser_conf) %>%
  group_by(conference = winner_conf) %>%
  summarise(wins = n(), .groups = "drop") %>%
  full_join(
    completed_games %>%
      filter(winner_conf != loser_conf) %>%
      group_by(conference = loser_conf) %>%
      summarise(losses = n(), .groups = "drop"),
    by = "conference"
  ) %>%
  mutate(wins = ifelse(is.na(wins), 0, wins),
         losses = ifelse(is.na(losses), 0, losses))

# Average Elo per conference
team_conf <- elo_ranking %>%
  left_join(
    completed_games %>%
      select(team = winner, conference = winner_conf) %>% distinct(),
    by = "team"
  ) %>%
  mutate(conference = ifelse(is.na(conference), "Unknown", conference))

conf_summary <- conf_summary %>%
  left_join(
    team_conf %>% group_by(conference) %>% summarise(avg_elo = mean(rating)),
    by = "conference"
  ) %>%
  arrange(desc(avg_elo)) %>%
  mutate(rank = row_number()) %>%
  select(rank, conference, avg_elo, wins, losses)

# -------------------------------
# Step 11: Write conference CSV
# -------------------------------
write_csv(
  conf_summary,
  file.path("CBB", "data", "CBB_Conference_Elo_2026.csv")
)
print(conf_summary)
```


```{r}
library(hoopR)
library(dplyr)
library(lubridate)
library(readr)

# -------------------------------
# Step 1: Load schedule
# -------------------------------
cbb_all <- load_mbb_schedule(seasons = 2026) %>%
  mutate(date = as.Date(date)) %>%
  filter(
    home_short_display_name != away_short_display_name,
    !is.na(home_short_display_name),
    !is.na(away_short_display_name)
  )

# -------------------------------
# Step 2: Filter date range
# -------------------------------
season_start <- as.Date("2025-11-01")
today <- Sys.Date()

cbb_sel <- cbb_all %>%
  filter(date >= season_start & date <= today)

if (nrow(cbb_sel) == 0) {
  warning("No games available yet. Using all available games.")
  cbb_sel <- cbb_all
}
if (nrow(cbb_sel) == 0) {
  cbb_sel <- cbb_all
}

# -------------------------------
# Step 3: Winner / loser dataset
# -------------------------------
cbb_clean <- cbb_sel %>%
  mutate(
    home_pts = as.numeric(home_score),
    away_pts = as.numeric(away_score),
    winner = if_else(home_pts > away_pts,
                     home_short_display_name,
                     away_short_display_name),
    loser  = if_else(home_pts < away_pts,
                     home_short_display_name,
                     away_short_display_name),
    winner_pts = if_else(home_pts > away_pts, home_pts, away_pts),
    loser_pts  = if_else(home_pts < away_pts, home_pts, away_pts),
    winner_conf_id = if_else(home_pts > away_pts,
                             home_conference_id,
                             away_conference_id),
    loser_conf_id  = if_else(home_pts < away_pts,
                             home_conference_id,
                             away_conference_id)
  ) %>%
  filter(!is.na(winner), !is.na(loser)) %>%
  select(date, winner, winner_pts, winner_conf_id,
         loser, loser_pts, loser_conf_id)

# -------------------------------
# Step 4: Conference lookup
# -------------------------------
conf_lookup <- cbb_all %>%
  filter(groups_is_conference == TRUE) %>%
  select(conference_id = groups_id,
         conference = groups_name) %>%
  distinct()

cbb_clean <- cbb_clean %>%
  left_join(conf_lookup,
            by = c("winner_conf_id" = "conference_id")) %>%
  rename(winner_conf = conference) %>%
  left_join(conf_lookup,
            by = c("loser_conf_id" = "conference_id")) %>%
  rename(loser_conf = conference) %>%
  mutate(
    winner_conf = ifelse(is.na(winner_conf), "Unknown", winner_conf),
    loser_conf  = ifelse(is.na(loser_conf), "Unknown", loser_conf)
  )

# -------------------------------
# Step 5: Initialize Elo
# -------------------------------
teams <- unique(c(cbb_clean$winner, cbb_clean$loser))

ratings <- data.frame(
  team = teams,
  rating = 1500,
  wins = 0,
  losses = 0,
  stringsAsFactors = FALSE
)

k_factor <- 30
num_iter <- 10

# -------------------------------
# Step 6: Elo computation
# -------------------------------
for (iter in seq_len(num_iter)) {
  for (i in seq_len(nrow(cbb_clean))) {
    
    w <- cbb_clean$winner[i]
    l <- cbb_clean$loser[i]
    
    rw <- ratings$rating[ratings$team == w]
    rl <- ratings$rating[ratings$team == l]
    
    expected_w <- 1 / (1 + 10^((rl - rw) / 400))
    margin <- cbb_clean$winner_pts[i] - cbb_clean$loser_pts[i]
    adj_k <- k_factor * log(abs(margin) + 1)
    delta <- adj_k * (1 - expected_w)
    
    ratings$rating[ratings$team == w] <- rw + delta
    ratings$rating[ratings$team == l] <- rl - delta
    
    ratings$wins[ratings$team == w] <- ratings$wins[ratings$team == w] + 1
    ratings$losses[ratings$team == l] <- ratings$losses[ratings$team == l] + 1
  }
  
  ratings <- ratings %>%
    mutate(rating = ifelse(wins + losses < 4, rating / 2, rating))
}

# -------------------------------
# Step 7: Best win
# -------------------------------
team_ratings <- ratings %>% select(team, rating)

best_wins <- cbb_clean %>%
  left_join(team_ratings, by = c("loser" = "team")) %>%
  rename(loser_elo = rating) %>%
  group_by(winner) %>%
  slice_max(loser_elo, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(team = winner,
         best_win = loser,
         best_win_elo = loser_elo)

# -------------------------------
# Step 8: Final Elo table
# -------------------------------
elo_ranking <- ratings %>%
  mutate(
    record = paste0(round(wins / 10, 1), "-", round(losses / 10, 1))
  ) %>%
  arrange(desc(rating)) %>%
  mutate(rank = row_number()) %>%
  left_join(best_wins, by = "team") %>%
  mutate(
    rating = round(rating, 1),
    best_win_elo = round(best_win_elo, 1)
  ) %>%
  select(rank, team, rating, record, best_win, best_win_elo)

write_csv(elo_ranking, file.path("CBB", "data", "CBB_Elo_2026.csv"))

# -------------------------------
# Step 9: Team → conference map
# -------------------------------
team_conf_map <- cbb_clean %>%
  select(team = winner, conference = winner_conf) %>%
  bind_rows(
    cbb_clean %>%
      select(team = loser, conference = loser_conf)
  ) %>%
  filter(conference != "Unknown") %>%
  distinct()

# -------------------------------
# Step 10: Conference averages + non-conf record
# -------------------------------
non_conf <- cbb_clean %>%
  filter(winner_conf != loser_conf,
         winner_conf != "Unknown",
         loser_conf != "Unknown")

conf_wins <- non_conf %>%
  count(conference = winner_conf, name = "wins")

conf_losses <- non_conf %>%
  count(conference = loser_conf, name = "losses")

conf_avg_elo <- elo_ranking %>%
  left_join(team_conf_map, by = "team") %>%
  group_by(conference) %>%
  summarise(avg_elo = mean(rating), .groups = "drop")

conf_summary <- full_join(conf_wins, conf_losses, by = "conference") %>%
  mutate(
    wins = ifelse(is.na(wins), 0, wins),
    losses = ifelse(is.na(losses), 0, losses)
  ) %>%
  left_join(conf_avg_elo, by = "conference") %>%
  arrange(desc(avg_elo)) %>%
  mutate(rank = row_number()) %>%
  select(rank, conference, avg_elo, wins, losses)

write_csv(
  conf_summary,
  file.path("CBB", "data", "CBB_Conference_Elo_2026.csv")
)

# -------------------------------
# Step 11: Individual conference standings
# -------------------------------
conference_standings <- elo_ranking %>%
  left_join(team_conf_map, by = "team") %>%
  group_by(conference) %>%
  arrange(desc(rating), .by_group = TRUE) %>%
  mutate(conf_rank = row_number()) %>%
  ungroup()

dir.create("conference_standings", showWarnings = FALSE)

for (conf in unique(conference_standings$conference)) {
  
  df <- conference_standings %>%
    filter(conference == conf) %>%
    select(
      rank = conf_rank,
      team,
      rating,
      record,
      best_win,
      best_win_elo
    )
  
file <- file.path(
  "CBB", "data",
  paste0(gsub("[^A-Za-z0-9]", "_", conf), "_Elo_2026.csv")
)
write_csv(df, file)
}
print("All Elo and conference files successfully created.")
```


```{r}
library(hoopR)
library(dplyr)
library(readr)

# ===============================
# USER SETTINGS
# ===============================
START_DATE <- Sys.Date()
END_DATE   <- Sys.Date() + 7
HCA <- 65             # home court advantage in Elo
ELO_BASELINE <- 1500
SPREAD_SCALE <- 35    # Elo points per basketball point (adjust as needed)

# -------------------------------
# Load FINAL Elo ratings
# -------------------------------
elo <- read_csv(
  file.path("CBB", "data", "CBB_Elo_2026.csv"),
  show_col_types = FALSE
) %>%
  select(team, rating)

# -------------------------------
# Load schedule
# -------------------------------
schedule <- load_mbb_schedule(seasons = 2026) %>%
  mutate(
    date = as.Date(date),
    home_score = as.numeric(home_score),
    away_score = as.numeric(away_score)
  )

# -------------------------------
# Filter unplayed games in window
# -------------------------------
future_games <- schedule %>%
  filter(
    date >= START_DATE,
    date <= END_DATE,
    (is.na(home_score) | home_score == 0),
    (is.na(away_score) | away_score == 0),
    !is.na(home_short_display_name),
    !is.na(away_short_display_name)
  )

if (nrow(future_games) == 0) {
  stop("No unplayed games found in selected time window.")
}

# -------------------------------
# Attach Elo ratings
# -------------------------------
games <- future_games %>%
  select(
    home_team = home_short_display_name,
    away_team = away_short_display_name,
    neutral_site
  ) %>%
  left_join(elo, by = c("home_team" = "team")) %>%
  rename(home_elo = rating) %>%
  left_join(elo, by = c("away_team" = "team")) %>%
  rename(away_elo = rating) %>%
  mutate(
    home_elo = ifelse(is.na(home_elo), ELO_BASELINE, home_elo),
    away_elo = ifelse(is.na(away_elo), ELO_BASELINE, away_elo)
  )

# -------------------------------
# Apply Home Court Advantage
# -------------------------------
games <- games %>%
  mutate(
    home_adj_elo = ifelse(neutral_site, home_elo, home_elo + HCA)
  )

# -------------------------------
# Win probabilities and spread
# -------------------------------
predictions <- games %>%
  mutate(
    home_win_pct = 1 / (1 + 10^((away_elo - home_adj_elo) / 400)),
    away_win_pct = 1 - home_win_pct,
    projected_spread = round((home_adj_elo - away_elo) / SPREAD_SCALE, 1)
  ) %>%
  transmute(
    team_1 = home_team,
    team_2 = away_team,
    team_1_win_pct = round(home_win_pct, 3),
    team_2_win_pct = round(away_win_pct, 3),
    projected_spread
  ) %>%
  arrange(desc(team_1_win_pct))

# -------------------------------
# Write CSV
# -------------------------------
write_csv(
  predictions,
  file.path("CBB", "data", "CBB_Elo_Future_Game_Predictions.csv")
)
print(predictions)
```

